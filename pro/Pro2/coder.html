<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Устойчивый PNG Кодер/Декодер</title>
    <style>
        /* Стили остаются такими же, как в предыдущей версии */
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Roboto, sans-serif; }
        body { background: linear-gradient(135deg, #1a2a6c, #3a7bd5); color: #333; padding: 15px; min-height: 100vh; }
        .container { max-width: 100%; margin: 0 auto; }
        header { text-align: center; color: white; margin-bottom: 20px; padding: 15px; border-radius: 12px; background: rgba(0,0,0,0.2); }
        h1 { font-size: 1.5rem; margin-bottom: 8px; }
        .app-card { background: white; border-radius: 16px; padding: 20px; box-shadow: 0 8px 25px rgba(0,0,0,0.15); margin-bottom: 20px; }
        .tab-buttons { display: flex; margin-bottom: 20px; border-radius: 12px; overflow: hidden; background: #f0f0f0; }
        .tab-button { flex: 1; padding: 12px 5px; border: none; background: none; font-weight: 600; cursor: pointer; }
        .tab-button.active { background: #3a7bd5; color: white; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .input-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: #444; }
        textarea, input[type="text"] { width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 10px; font-size: 1rem; resize: vertical; min-height: 120px; }
        input[type="file"] { width: 100%; padding: 12px; border: 2px dashed #e0e0e0; border-radius: 10px; background: #f9f9f9; }
        .button-group { display: flex; flex-direction: column; gap: 12px; margin-top: 25px; }
        button { padding: 14px; border: none; border-radius: 10px; font-weight: 600; font-size: 1rem; cursor: pointer; transition: all 0.3s; }
        .encode-btn { background: linear-gradient(to right, #3a7bd5, #00d2ff); color: white; }
        .decode-btn { background: linear-gradient(to right, #f46b45, #eea849); color: white; }
        .convert-btn { background: linear-gradient(to right, #56ab2f, #a8e063); color: white; }
        .result-container { margin-top: 25px; padding: 20px; border-radius: 12px; background: #f8f9fa; border: 2px solid #e9ecef; display: none; }
        .result-container.active { display: block; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .image-preview { max-width: 100%; border-radius: 10px; margin-top: 10px; border: 1px solid #ddd; display: block; }
        .text-result { background: white; padding: 15px; border-radius: 8px; margin-top: 10px; border: 1px solid #e0e0e0; word-wrap: break-word; }
        .download-btn { display: inline-block; margin-top: 15px; padding: 12px 20px; background: #3a7bd5; color: white; text-decoration: none; border-radius: 8px; font-weight: 600; text-align: center; }
        .info-box { background: #e8f4fd; border-left: 4px solid #3a7bd5; padding: 12px; margin: 20px 0; border-radius: 0 8px 8px 0; font-size: 0.9rem; line-height: 1.5; }
        .loading { display: none; text-align: center; margin: 15px 0; }
        .loading.active { display: block; }
        .spinner { border: 4px solid rgba(0,0,0,0.1); border-radius: 50%; border-top: 4px solid #3a7bd5; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        footer { text-align: center; color: rgba(255,255,255,0.7); font-size: 0.85rem; margin-top: 20px; padding: 15px; }
        
        /* Новые стили для настроек */
        .settings-group { display: flex; flex-wrap: wrap; gap: 15px; margin: 15px 0; }
        .setting-item { flex: 1; min-width: 150px; }
        .setting-item label { font-size: 0.9rem; }
        .setting-item select, .setting-item input[type="number"] { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px; }
        
        /* Адаптивные стили */
        @media (max-width: 480px) {
            .settings-group { flex-direction: column; }
            .setting-item { min-width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Устойчивый PNG Стеганограф</h1>
            <p class="description">Кодируйте текст в изображение с защитой от конвертации в JPG</p>
        </header>
        
        <main class="app-card">
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="encode">Кодировать</button>
                <button class="tab-button" data-tab="decode">Декодировать</button>
                <button class="tab-button" data-tab="settings">Настройки</button>
            </div>
            
            <!-- Вкладка кодирования -->
            <div id="encode" class="tab-content active">
                <div class="input-group">
                    <label for="encode-text">Текст для кодирования:</label>
                    <textarea id="encode-text" placeholder="Введите текст для сокрытия в изображении..."></textarea>
                </div>
                
                <div class="input-group">
                    <label for="encode-image">Изображение-контейнер:</label>
                    <input type="file" id="encode-image" accept="image/*">
                </div>
                
                <div class="info-box">
                    <strong>Улучшенный алгоритм:</strong> Данные кодируются в младшие биты RGB-каналов с коррекцией ошибок. Даже после конвертации в JPG текст может быть восстановлен (с некоторыми ограничениями).
                </div>
                
                <div class="button-group">
                    <button id="encode-btn" class="encode-btn">Зашифровать текст в изображение</button>
                </div>
            </div>
            
            <!-- Вкладка декодирования -->
            <div id="decode" class="tab-content">
                <div class="input-group">
                    <label for="decode-image">Изображение для декодирования:</label>
                    <input type="file" id="decode-image" accept="image/*">
                </div>
                
                <div class="info-box">
                    <strong>Важно:</strong> Можно декодировать как PNG, так и JPG/WebP изображения, полученные после пересылки. Однако при сильном сжатии часть данных может быть потеряна.
                </div>
                
                <div class="button-group">
                    <button id="decode-btn" class="decode-btn">Извлечь текст из изображения</button>
                </div>
            </div>
            
            <!-- Вкладка настроек -->
            <div id="settings" class="tab-content">
                <div class="settings-group">
                    <div class="setting-item">
                        <label for="robustness">Устойчивость:</label>
                        <select id="robustness">
                            <option value="1">Низкая (больше текста)</option>
                            <option value="2" selected>Средняя</option>
                            <option value="3">Высокая (меньше текста)</option>
                            <option value="4">Максимальная</option>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <label for="bits-per-channel">Бит на канал:</label>
                        <select id="bits-per-channel">
                            <option value="1">1 бит (наименее заметно)</option>
                            <option value="2" selected>2 бита (рекомендуется)</option>
                            <option value="3">3 бита (устойчивее)</option>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <label for="error-correction">Коррекция ошибок:</label>
                        <select id="error-correction">
                            <option value="none">Нет</option>
                            <option value="low" selected>Низкая</option>
                            <option value="medium">Средняя</option>
                            <option value="high">Высокая</option>
                        </select>
                    </div>
                </div>
                
                <div class="info-box">
                    <strong>Рекомендации:</strong><br>
                    • Для пересылки через Telegram используйте "Высокую" устойчивость<br>
                    • 2 бита на канал - оптимальный баланс между вместимостью и устойчивостью<br>
                    • Коррекция ошибок увеличивает размер данных, но повышает надежность
                </div>
            </div>
            
            <!-- Индикатор загрузки -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p id="loading-text">Обработка...</p>
            </div>
            
            <!-- Результаты -->
            <div class="result-container" id="result-container">
                <h3 class="result-title" id="result-title">Результат</h3>
                <div id="result-content"></div>
            </div>
        </main>
        
        <footer>
            <p>Устойчивый стеганограф © 2023 | Защищено от конвертации в JPG</p>
        </footer>
    </div>

    <script>
        // Конфигурация
        const config = {
            robustness: 2,          // Устойчивость к сжатию
            bitsPerChannel: 2,      // Сколько бит использовать на канал
            errorCorrection: 'low'  // Уровень коррекции ошибок
        };
        
        // Элементы DOM
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        const encodeText = document.getElementById('encode-text');
        const encodeImageInput = document.getElementById('encode-image');
        const decodeImageInput = document.getElementById('decode-image');
        const robustnessSelect = document.getElementById('robustness');
        const bitsPerChannelSelect = document.getElementById('bits-per-channel');
        const errorCorrectionSelect = document.getElementById('error-correction');
        const encodeBtn = document.getElementById('encode-btn');
        const decodeBtn = document.getElementById('decode-btn');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loading-text');
        const resultContainer = document.getElementById('result-container');
        const resultTitle = document.getElementById('result-title');
        const resultContent = document.getElementById('result-content');
        
        // Инициализация настроек
        robustnessSelect.value = config.robustness;
        bitsPerChannelSelect.value = config.bitsPerChannel;
        errorCorrectionSelect.value = config.errorCorrection;
        
        // Обновление конфигурации
        robustnessSelect.addEventListener('change', (e) => {
            config.robustness = parseInt(e.target.value);
        });
        
        bitsPerChannelSelect.addEventListener('change', (e) => {
            config.bitsPerChannel = parseInt(e.target.value);
        });
        
        errorCorrectionSelect.addEventListener('change', (e) => {
            config.errorCorrection = e.target.value;
        });
        
        // Переключение вкладок
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === tabId) content.classList.add('active');
                });
                resultContainer.classList.remove('active');
            });
        });
        
        // Показать результаты
        function showResult(title, content) {
            resultTitle.textContent = title;
            resultContent.innerHTML = content;
            resultContainer.classList.add('active');
            resultContainer.scrollIntoView({ behavior: 'smooth' });
        }
        
        // Функция добавления коррекции ошибок (упрощенный Reed-Solomon)
        function addErrorCorrection(data, level) {
            if (level === 'none') return data;
            
            // Простое дублирование данных в зависимости от уровня
            const repetitions = {
                'low': 2,
                'medium': 3,
                'high': 4
            }[level] || 1;
            
            let result = new Uint8Array(data.length * repetitions);
            for (let i = 0; i < repetitions; i++) {
                result.set(data, i * data.length);
            }
            
            return result;
        }
        
        // Функция исправления ошибок
        function correctErrors(dataWithEC, level) {
            if (level === 'none') return dataWithEC;
            
            const repetitions = {
                'low': 2,
                'medium': 3,
                'high': 4
            }[level] || 1;
            
            const chunkSize = dataWithEC.length / repetitions;
            let result = new Uint8Array(chunkSize);
            
            // Простейшая коррекция: выбираем наиболее часто встречающееся значение
            for (let i = 0; i < chunkSize; i++) {
                const counts = new Map();
                for (let r = 0; r < repetitions; r++) {
                    const value = dataWithEC[r * chunkSize + i];
                    counts.set(value, (counts.get(value) || 0) + 1);
                }
                
                // Находим значение с максимальным количеством повторений
                let maxCount = 0;
                let bestValue = 0;
                for (const [value, count] of counts.entries()) {
                    if (count > maxCount) {
                        maxCount = count;
                        bestValue = value;
                    }
                }
                result[i] = bestValue;
            }
            
            return result;
        }
        
        // Улучшенное кодирование в RGB-каналы
        async function robustEncode() {
            const text = encodeText.value.trim();
            if (!text) {
                alert('Введите текст для кодирования');
                return;
            }
            
            loadingText.textContent = 'Кодирование текста...';
            loading.classList.add('active');
            
            try {
                // Подготовка текста
                const textEncoder = new TextEncoder();
                const textBytes = textEncoder.encode(text);
                
                // Добавляем контрольную сумму и метку
                const metadata = new Uint8Array(8);
                const textLength = textBytes.length;
                
                // Сохраняем длину текста
                metadata[0] = (textLength >> 24) & 0xFF;
                metadata[1] = (textLength >> 16) & 0xFF;
                metadata[2] = (textLength >> 8) & 0xFF;
                metadata[3] = textLength & 0xFF;
                
                // Добавляем сигнатуру для идентификации
                metadata[4] = 0x53; // 'S'
                metadata[5] = 0x54; // 'T'
                metadata[6] = 0x45; // 'E'
                metadata[7] = 0x47; // 'G'
                
                // Объединяем метаданные и текст
                const dataToEncode = new Uint8Array(8 + textBytes.length);
                dataToEncode.set(metadata);
                dataToEncode.set(textBytes, 8);
                
                // Применяем коррекцию ошибок
                const dataWithEC = addErrorCorrection(dataToEncode, config.errorCorrection);
                
                // Конвертируем в биты
                const bits = [];
                for (let byte of dataWithEC) {
                    for (let i = 7; i >= 0; i--) {
                        bits.push((byte >> i) & 1);
                    }
                }
                
                // Создаем или загружаем изображение
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                if (encodeImageInput.files && encodeImageInput.files[0]) {
                    const imageFile = encodeImageInput.files[0];
                    const imageBitmap = await createImageBitmap(imageFile);
                    canvas.width = imageBitmap.width;
                    canvas.height = imageBitmap.height;
                    ctx.drawImage(imageBitmap, 0, 0);
                } else {
                    // Создаем изображение с градиентом
                    canvas.width = 800;
                    canvas.height = 600;
                    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    gradient.addColorStop(0, '#3a7bd5');
                    gradient.addColorStop(0.5, '#00d2ff');
                    gradient.addColorStop(1, '#56ab2f');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Добавляем видимый текст
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Изображение содержит скрытые данные', canvas.width / 2, 40);
                    ctx.font = '14px Arial';
                    ctx.fillText('Для извлечения текста используйте декодер', canvas.width / 2, canvas.height - 20);
                }
                
                // Получаем данные изображения
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Проверяем, достаточно ли места
                const availableBits = (data.length / 4) * 3 * config.bitsPerChannel;
                if (bits.length > availableBits) {
                    loading.classList.remove('active');
                    const maxChars = Math.floor((availableBits / 8) * 0.7); // С учетом коррекции ошибок
                    alert(`Текст слишком длинный. Максимум для этого изображения: ~${maxChars} символов`);
                    return;
                }
                
                // Кодируем биты в изображение
                let bitIndex = 0;
                const mask = (1 << config.bitsPerChannel) - 1;
                
                for (let i = 0; i < data.length && bitIndex < bits.length; i += 4) {
                    // Пропускаем альфа-канал для совместимости с JPG
                    for (let channel = 0; channel < 3 && bitIndex < bits.length; channel++) {
                        if (bitIndex < bits.length) {
                            // Извлекаем биты для этого канала
                            let value = 0;
                            for (let b = 0; b < config.bitsPerChannel && bitIndex < bits.length; b++) {
                                value = (value << 1) | bits[bitIndex++];
                            }
                            
                            // Встраиваем биты в канал
                            const pixelValue = data[i + channel];
                            // Очищаем младшие биты и добавляем наши данные
                            const newValue = (pixelValue & ~mask) | value;
                            data[i + channel] = newValue;
                        }
                    }
                }
                
                // Возвращаем данные на холст
                ctx.putImageData(imageData, 0, 0);
                
                // Создаем PNG
                const pngUrl = canvas.toDataURL('image/png');
                const timestamp = new Date().getTime();
                const downloadLink = `<a href="${pngUrl}" download="stego_${timestamp}.png" class="download-btn">Скачать изображение со скрытым текстом</a>`;
                
                // Показываем результат
                loading.classList.remove('active');
                showResult('Текст успешно зашифрован!', `
                    <p>Текст скрыт в RGB-каналах изображения с устойчивостью к конвертации.</p>
                    <p>Длина текста: ${text.length} символов</p>
                    <p>Уровень защиты: ${config.robustness === 1 ? 'Низкий' : config.robustness === 2 ? 'Средний' : config.robustness === 3 ? 'Высокий' : 'Максимальный'}</p>
                    <img src="${pngUrl}" alt="Изображение со скрытым текстом" class="image-preview">
                    ${downloadLink}
                    <div class="info-box">
                        <strong>Советы для пересылки через Telegram:</strong><br>
                        1. Отправляйте как "Файл" (не как "Фото")<br>
                        2. Попросите получателя сохранить файл, а не переотправлять<br>
                        3. Максимальный размер текста для надежной передачи: ~500 символов
                    </div>
                `);
                
            } catch (error) {
                console.error('Ошибка кодирования:', error);
                loading.classList.remove('active');
                alert('Ошибка при кодировании текста');
            }
        }
        
        // Улучшенное декодирование
        async function robustDecode() {
            if (!decodeImageInput.files || !decodeImageInput.files[0]) {
                alert('Выберите изображение для декодирования');
                return;
            }
            
            loadingText.textContent = 'Декодирование текста...';
            loading.classList.add('active');
            
            try {
                const imageFile = decodeImageInput.files[0];
                const imageBitmap = await createImageBitmap(imageFile);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = imageBitmap.width;
                canvas.height = imageBitmap.height;
                ctx.drawImage(imageBitmap, 0, 0);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Извлекаем биты из изображения
                const bits = [];
                const mask = (1 << config.bitsPerChannel) - 1;
                
                for (let i = 0; i < data.length; i += 4) {
                    for (let channel = 0; channel < 3; channel++) {
                        const pixelValue = data[i + channel];
                        // Извлекаем младшие биты
                        for (let b = config.bitsPerChannel - 1; b >= 0; b--) {
                            bits.push((pixelValue >> b) & 1);
                        }
                    }
                }
                
                // Конвертируем биты в байты
                const bytes = [];
                for (let i = 0; i < bits.length; i += 8) {
                    if (i + 8 > bits.length) break;
                    
                    let byte = 0;
                    for (let j = 0; j < 8; j++) {
                        byte = (byte << 1) | bits[i + j];
                    }
                    bytes.push(byte);
                }
                
                // Применяем коррекцию ошибок
                const correctedBytes = correctErrors(new Uint8Array(bytes), config.errorCorrection);
                
                // Проверяем сигнатуру
                if (correctedBytes[4] !== 0x53 || correctedBytes[5] !== 0x54 || 
                    correctedBytes[6] !== 0x45 || correctedBytes[7] !== 0x47) {
                    loading.classList.remove('active');
                    alert('Не удалось найти скрытые данные в изображении');
                    return;
                }
                
                // Извлекаем длину текста
                const textLength = (correctedBytes[0] << 24) | 
                                  (correctedBytes[1] << 16) | 
                                  (correctedBytes[2] << 8) | 
                                  correctedBytes[3];
                
                if (textLength <= 0 || textLength > correctedBytes.length - 8) {
                    loading.classList.remove('active');
                    alert('Некорректные данные в изображении');
                    return;
                }
                
                // Извлекаем текст
                const textBytes = correctedBytes.slice(8, 8 + textLength);
                const textDecoder = new TextDecoder();
                const decodedText = textDecoder.decode(textBytes);
                
                // Показываем результат
                loading.classList.remove('active');
                showResult('Текст успешно извлечен!', `
                    <p>Из изображения извлечен следующий текст:</p>
                    <div class="text-result">${decodedText}</div>
                    <p>Длина текста: ${textLength} символов</p>
                    <p>Формат изображения: ${imageFile.type || 'неизвестен'}</p>
                    <div class="info-box">
                        ${imageFile.type !== 'image/png' ? 
                          '<strong>Внимание:</strong> Изображение было конвертировано в ' + imageFile.type + 
                          '. Некоторые данные могли быть потеряны при сжатии.' : 
                          '<strong>Отлично!</strong> Изображение в формате PNG, данные сохранены полностью.'}
                    </div>
                `);
                
            } catch (error) {
                console.error('Ошибка декодирования:', error);
                loading.classList.remove('active');
                alert('Ошибка при декодировании текста. Попробуйте изменить настройки декодера.');
            }
        }
        
        // Обработчики событий
        encodeBtn.addEventListener('click', robustEncode);
        decodeBtn.addEventListener('click', robustDecode);
        
        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            encodeText.placeholder = `Это текст будет скрыт в изображении.

Улучшенный алгоритм кодирования позволяет сохранить данные даже после конвертации изображения в JPG (как это делает Telegram).

Используйте настройки для оптимизации под конкретные условия передачи.`;
            
            // Показываем подсказку
            setTimeout(() => {
                showResult('Добро пожаловать!', `
                    <p>Это улучшенный стеганограф с защитой от конвертации в JPG.</p>
                    <div class="info-box">
                        <strong>Как использовать:</strong><br>
                        1. Введите текст на вкладке "Кодировать"<br>
                        2. Настройте параметры на вкладке "Настройки"<br>
                        3. Полученное изображение можно отправлять через Telegram<br>
                        4. Для извлечения текста используйте вкладку "Декодировать"
                    </div>
                    <p>Алгоритм кодирует данные в младшие биты RGB-каналов, что делает их более устойчивыми к сжатию.</p>
                `);
            }, 1000);
        });
    </script>
</body>
</html>